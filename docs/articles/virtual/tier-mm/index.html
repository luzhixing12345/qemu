<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>
        Document
    </title>
    <link rel='stylesheet' href=../../../css/index.css />
    <link rel='stylesheet' href=../../../css/c.css /><link rel='stylesheet' href=../../../css/makefile.css /><link rel='stylesheet' href=../../../css/shell.css /><link rel='stylesheet' href=../../../css/txt.css />
    <link rel="icon" href="https://raw.githubusercontent.com/learner-lu/picbed/master/logo.png">
</head>

<body class="light">
    <a href="https://github.com/luzhixing12345/qemu.git" target="_blank" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <div class="header-navigator"><ul><li><a href="#h1-0">tier-mm</a><ul><li><a href="#h2-1">分层内存管理在虚拟化的挑战</a></li></ul><ul><li><a href="#h2-2">动态内存分区</a><ul><li><a href="#h3-3">分层内存管理背景</a></li></ul><ul><li><a href="#h3-4">动态内存分区的概念</a></li></ul><ul><li><a href="#h3-5">动态内存分区的实现</a></li></ul><ul><li><a href="#h3-6">应用场景</a></li></ul><ul><li><a href="#h3-7">总结</a></li></ul></li></ul><ul><li><a href="#h2-8">PML</a><ul><li><a href="#h3-9">PML 的背景和需求</a></li></ul><ul><li><a href="#h3-10">PML 的工作原理</a></li></ul><ul><li><a href="#h3-11">PML 的优点</a></li></ul><ul><li><a href="#h3-12">使用场景</a></li></ul></li></ul><ul><li><a href="#h2-13">vTMM 的设计优势和对比缺点</a><ul><li><a href="#h4-14">设计优势</a></li></ul><ul><li><a href="#h4-15">对比缺点</a></li></ul></li></ul></li></ul></div><div class='markdown-body'><h1 id="h1-0">tier-mm</h1><h2 id="h2-1">分层内存管理在虚拟化的挑战</h2><p>快内存(FMem)和慢内存(SMem)组成了分层内存系统.研究人员专注于将活动(热)页面放入 FMem 中,将非活动(冷)页面放入 SMem 中,以获得最佳性能.经典的管理方法通过页面跟踪、分类和迁移来实现目标.按照这种设计,许多先进的技术被开发出来,例如Thermostat [1]、HeMem [39]、Nimble [43]、HeteroOS [29]、RAMinate [21]等.不幸的是,它们都不能提供有效的管理.虚拟化.分层内存管理面临虚拟化的新挑战主要包括:</p><ul><li><b>性能隔离</b>:<p>多虚拟机(VM)并行运行会产生强烈的内存竞争,例如使用Intel Optane内存模式(MM)作为直接映射缓存的情况下,多虚拟机并行运行会导致DRAM缓存污染,DRAM缓存未命中次数增加2到4倍​​.</p></li></ul><ul><li><b>上下文切换开销</b>:<p>虚拟化引入了VM上下文,因此需要尽量减少昂贵的VM陷阱(VMTraps,例如在客户机和宿主机之间的上下文切换).例如,HeMem采用的基于写保护的页面迁移方法会因为写入异常处理而引发大量VMTraps,导致性能下降​​.</p></li></ul><ul><li><b>多样化的内存访问模式</b>:<p>在云环境中,不同的应用在多个虚拟机中并行运行,表现出更多样的内存访问模式.这对多虚拟机的页面放置策略提出了新的挑战,要求系统能够灵活适应不同的内存访问模式​​.</p></li></ul><ul><li><b>内存超分配</b>:<p>在分层内存系统中,虚拟机内存超分配(VM memory overcommit)需要处理不同于传统DRAM系统的设计空间.虽然大容量的慢速内存(SMem)能够保证充足的虚拟机内存容量,但快速内存(FMem)仍然是稀缺资源.理想的管理应在多个虚拟机之间动态平衡快速内存的使用,以实现更好的整体性能​​.</p></li></ul><p>分层内存管理设计进行比较,并分析了页面跟踪、分类和迁移等关键组件</p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20240530155925.png"><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20240530155925.png" alt="20240530155925"></a></p><p>页面跟踪捕获内存访问信息以进行内存管理.页表(PT)扫描通过定期检查和清除访问/脏位来跟踪内存访问.特别是,针对虚拟化系统,RAMinate 会扫描 EPT,称为 EPT 扫描仪.然而,如果没有适当的优化,PT 扫描可能会因为额外的 MMU 压力而导致不可接受的开销.此外,DAMON[30]是一个Linux内核内存数据访问监控框架,它还检查访问的位以监控页面.它采用区域采样来减少开销,但无法确定不同应用的区域数量来控制最佳精度和开销.恒温器通过 BadgerTrap [18] 监视页面错误来跟踪页面.然而,它仅随机分析总内存的 0.5%,如果分析所有页面,则会导致速度降低数倍 [18].类似地,自动分层通过 NUMA 页面错误监控来跟踪多层内存的内存访问. HeMem 通过 Intel PEBS [25] 跟踪页面,这对虚拟化不友好.由于虚拟化的安全隔离,Hypervisor无法使用PEBS跟踪VM内存访问. PEBS 设施无法在主机端存储访客线性地址,因为访客无法写入主机的 PEBS 缓冲区(由</p><p>页面分类:我们根据访问模式对页面进行分类,以确定要放置在 FMem 中的热集.现有设计通过使用LRU算法[21,29,31,43]或固定阈值方法[1,39]来区分热页和冷页. LRU 用于交换 Linux 内存子系统中的不活动(冷)页面.然而,它不适合跟踪热点页面,因为它关注的是页面访问的顺序而不是访问频率.我们将通过第 4.8 节中的实验来证明这一点.我们观察到使用固定阈值无法适应不同的内存访问模式(§4.5).对于匿名页面分类,自动分层使用访问计数排名,这与我们的设计类似.然而,它对读和写的处理是统一的.我们应该根据不同的性能特征来权衡读取和写入,尤其是带宽</p><p>页面迁移:它是页面放置策略的执行者. Raw Linux ,Nimble 通过并行和页面交换提供高 THP 迁移吞吐量. Autotiering 采用与 Nimble 相同的设计.由于在复制数据之前取消映射页面,两者都会在迁移过程中产生长时间的页面访问暂停. HeMem 使用页面写保护来减少迁移期间的页面访问暂停,但在虚拟化中,写保护会触发昂贵的 VMTrap,例如影子分页同步</p><h2 id="h2-2">动态内存分区</h2><p>分层内存管理中的动态内存分区(Dynamic Memory Partitioning)是一种内存管理技术,用于在多层次内存架构中高效地分配和管理内存资源.该技术通过动态调整内存分区的大小和位置,以适应不同工作负载的需求,提高系统整体性能和资源利用率.</p><h3 id="h3-3">分层内存管理背景</h3><p>在现代计算系统中,内存通常分为多个层次,每层具有不同的性能和容量特性.典型的内存层次结构包括:</p><ul><li><b>缓存(Cache)</b>:高速但容量小的存储器,位于处理器内部.</li></ul><ul><li><b>主内存(DRAM)</b>:速度较快、容量适中的内存.</li></ul><ul><li><b>持久性内存(NVM,如Intel Optane)</b>:速度较慢但容量较大的非易失性存储器.</li></ul><ul><li><b>磁盘存储(HDD/SSD)</b>:速度更慢但容量巨大的存储设备.</li></ul><h3 id="h3-4">动态内存分区的概念</h3><p>动态内存分区技术的主要目标是根据应用程序的需求和系统负载情况,实时调整内存资源的分配,以优化性能和资源利用率.其主要特点包括:</p><ol start="1"><li><b>动态调整</b>:根据当前的工作负载和内存访问模式,实时调整内存分区的大小和位置.例如,当某个应用程序需要更多的高速缓存时,可以临时增加其分配的缓存空间.</li></ol><ol start="2"><li><b>按需分配</b>:内存资源的分配是按需进行的,而不是静态预先分配的.这种方式可以避免内存浪费,并确保资源在需要时可用.</li></ol><ol start="3"><li><b>多层次协调</b>:在多层次内存架构中,动态内存分区需要在不同层次之间进行协调.例如,可以根据访问频率和数据重要性,将数据在缓存、主内存和持久性内存之间动态迁移.</li></ol><h3 id="h3-5">动态内存分区的实现</h3><p>实现动态内存分区需要考虑以下几个方面:</p><ol start="1"><li><b>内存监控</b>:实时监控各个应用程序的内存使用情况和访问模式,收集内存需求的动态变化数据.</li></ol><ol start="2"><li><b>内存分配算法</b>:设计高效的内存分配算法,根据监控数据动态调整内存分区.例如,可以使用基于访问频率的分配策略,将高频访问的数据分配到更高速的内存层次.</li></ol><ol start="3"><li><b>数据迁移</b>:在不同内存层次之间高效地迁移数据,确保数据在需要时能够快速访问.数据迁移需要尽量减少对系统性能的影响.</li></ol><ol start="4"><li><b>内存隔离</b>:确保不同应用程序或虚拟机之间的内存隔离,防止数据泄露和相互干扰.</li></ol><h3 id="h3-6">应用场景</h3><p>动态内存分区技术在以下场景中尤为重要:</p><ul><li><b>虚拟化环境</b>:在虚拟化环境中,不同虚拟机对内存资源的需求可能动态变化.动态内存分区可以根据虚拟机的实时需求调整内存分配,提高资源利用率.</li></ul><ul><li><b>大数据和云计算</b>:在大数据处理和云计算环境中,工作负载和数据访问模式可能高度动态化.通过动态调整内存分区,可以更好地适应数据访问模式的变化,提高处理性能.</li></ul><ul><li><b>高性能计算</b>:在高性能计算中,不同任务对内存的需求可能差异很大.动态内存分区可以根据任务需求优化内存分配,确保计算效率最大化.</li></ul><h3 id="h3-7">总结</h3><p>分层内存管理中的动态内存分区是一种先进的内存管理技术,通过实时监控和调整内存资源的分配,提高了系统的性能和资源利用率.该技术在虚拟化、大数据处理和高性能计算等领域具有广泛的应用前景.</p><h2 id="h2-8">PML</h2><p>Intel 的 Page-Modification Logging (PML) 是一种硬件辅助的内存管理技术,用于高效跟踪虚拟机中被修改的内存页.PML 主要设计用于虚拟化环境,特别是为了优化虚拟机的迁移和快照操作.</p><h3 id="h3-9">PML 的背景和需求</h3><p>在虚拟化环境中,当需要将一个运行中的虚拟机从一个物理主机迁移到另一个主机,或者创建虚拟机的快照时,需要跟踪虚拟机中哪些内存页被修改过.这些操作通常涉及到大量的内存页,需要频繁地检查和记录页的修改状态.如果依赖软件层面的处理,这会产生很大的性能开销.</p><h3 id="h3-10">PML 的工作原理</h3><p>PML 提供了一种硬件机制,允许高效地跟踪被修改的内存页.其工作原理如下:</p><ol start="1"><li><b>硬件支持的日志记录</b>:<ul><li>PML 引入了一种新的日志结构,即 PML 日志.</li></ul><ul><li>当虚拟机中的某个内存页被修改时,硬件会自动将该页的地址记录到 PML 日志中.</li></ul></li></ol><ol start="2"><li><b>减少开销</b>:<ul><li>通过硬件直接记录被修改的页地址,避免了频繁的虚拟化管理程序(如 Hypervisor)干预,从而减少了性能开销.</li></ul></li></ol><ol start="3"><li><b>日志处理</b>:<ul><li>PML 日志是一个固定大小的环形缓冲区.当日志被填满时,CPU 会产生一个 VM 退出(VM-exit)事件,通知虚拟化管理程序处理日志.</li></ul><ul><li>虚拟化管理程序读取并清空日志后,PML 日志可以继续使用.</li></ul></li></ol><ol start="4"><li><b>增强迁移和快照性能</b>:<ul><li>在虚拟机迁移过程中,PML 可以高效地确定哪些内存页被修改过,只有这些页需要复制到目标主机,从而减少了迁移时间.</li></ul><ul><li>在快照操作中,PML 可以记录自上次快照以来被修改的页,提高快照的增量备份效率.</li></ul></li></ol><h3 id="h3-11">PML 的优点</h3><ol start="1"><li><b>性能提升</b>:通过硬件辅助的日志记录,减少了虚拟化管理程序频繁检查页修改状态的开销,提高了虚拟机迁移和快照操作的性能.</li></ol><ol start="2"><li><b>高效内存管理</b>:PML 能够准确跟踪被修改的内存页,确保在迁移和快照过程中只处理必要的数据,减少了不必要的数据传输.</li></ol><ol start="3"><li><b>简化开发</b>:虚拟化管理程序可以依赖硬件提供的日志记录功能,简化了内存页修改跟踪的实现.</li></ol><h3 id="h3-12">使用场景</h3><p>PML 主要在以下场景中具有重要应用:</p><ul><li><b>虚拟机迁移(Live Migration)</b>:在虚拟机迁移过程中,PML 能够高效地确定和复制被修改的内存页,减少迁移时间和性能影响.</li></ul><ul><li><b>虚拟机快照(Snapshotting)</b>:在创建虚拟机快照时,PML 提供了准确的页修改记录,支持高效的增量快照.</li></ul><ul><li><b>灾难恢复</b>:在虚拟化环境的灾难恢复场景中,PML 可以帮助快速识别和恢复关键数据,提升恢复速度.</li></ul><h2 id="h2-13">vTMM 的设计优势和对比缺点</h2><p>根据论文第 2.2 节的总结,vTMM (Tiered Memory Management) 与其他分层内存管理方法相比,主要有以下设计优势和对比缺点:</p><h4 id="h4-14">设计优势</h4><ol start="1"><li><b>基于 PML 的 GPT 扫描器</b>:<ul><li>vTMM 使用基于 PML (Page Modification Logging) 的 GPT (Guest Page Table) 扫描器,仅追踪活跃进程的页面,设计了多级队列以减少页面追踪的开销.</li></ul></li></ol><ol start="2"><li><b>冷热页面分类</b>:<ul><li>采用基于桶排序的冷热页面分类器,能够适应各种内存访问模式,准确区分出热点页面和冷门页面 .</li></ul></li></ol><ol start="3"><li><b>并行页面迁移</b>:<ul><li>vTMM 在最小访问暂停的情况下并行迁移页面,并巧妙地处理脏页面,通过利用 PML 来减少迁移过程中对 VM 的影响 .</li></ul></li></ol><ol start="4"><li><b>动态内存池</b>:<ul><li>设计了一个内存池,动态地在虚拟机之间分配内存,以提高多虚拟机同时运行时的性能.通过这种方式,vTMM 能够有效地管理和优化内存资源的使用 .</li></ul></li></ol><ol start="5"><li><b>透明大页支持</b>:<ul><li>扩展了 vTMM 以支持透明大页(THP),并在 DRAM+NVM 系统和 CXL-Memory 系统上进行了广泛的评估和对比 .</li></ul></li></ol><h4 id="h4-15">对比缺点</h4><ol start="1"><li><b>页面追踪</b>:<ul><li>其他方法如 PT 扫描、页面错误监控和 PEBS(Processor Event-Based Sampling)在虚拟化环境中的应用存在困难.PT 扫描方法会引起较大的开销,而页面错误监控在细粒度页面管理时会导致巨大开销  .</li></ul></li></ol><ol start="2"><li><b>分类方法</b>:<ul><li>一些现有的方法无法灵活适应不同的内存访问模式,而 vTMM 的桶排序方法能更好地适应各种模式,精确分类页面 .</li></ul></li></ol><ol start="3"><li><b>页面迁移策略</b>:<ul><li>现有方法在处理页面迁移时可能导致较长的访问暂停,而 vTMM 能通过并行迁移和有效处理脏页面来减少对 VM 的影响 .</li></ul></li></ol><ol start="4"><li><b>内存管理灵活性</b>:<ul><li>vTMM 通过动态内存池在虚拟机之间重新分配内存,比一些静态分配的方法在资源利用率和性能上有明显优势 .</li></ul></li></ol><p>综上所述,vTMM 通过创新性的页面追踪和分类方法、并行页面迁移策略,以及灵活的内存池管理,克服了现有分层内存管理方法的一些不足,在提升虚拟机性能和资源利用效率方面具有明显的优势.</p><hr><p>在我们的工作中,英特尔 PML 机制被使用了两次:捕获 GPT 的 A/D 位设置(第 3.2 节)并优化页面迁移的脏处理,如虚拟机实时迁移(第 3.4 节). Intel PML 是一种硬件辅助虚拟化技术,可跟踪 VM 实时迁移的脏页 [3, 11].在 PML 出现之前,虚拟机管理程序对所有 VM 页面进行写保护,修改迁移的页面会触发昂贵的 VMTrap 来跟踪脏页面.在来宾物理访问之前,处理器可能会确定它首先需要为其 EPT 条目 (EPTE) 设置已访问或脏位 [26].如果启用了 PML,则当脏位被设置时,MMU 会将所访问的常规/大页面的客户物理地址 (GPA) 记录到 PML 缓冲区.每个 VCPU 都有一个单独的 PML 缓冲区,其中包含 512 个条目(即 4KB 页).页面修改日志已满事件将触发虚拟机退出[26].然后,管理程序将刷新 PML 缓冲区以更新脏页位图 [6].特别是,每当 VM 由于某种原因退出时,虚拟机管理程序都会刷新 PML 缓冲区. hypervisor需要首先清除EPT中的脏位,以确保写入页面时会设置其脏位.此外,虚拟机管理程序还需要刷新相应的 TLB(包括常规 TLB 和 ETLB [26])以强制执行 2D 页遍历.总而言之,Intel PML 可以跟踪硬件中虚拟机的脏页,而不会触发昂贵的 VMTrap</p><p>为了减少设置A/D位和刷新TLB的开销(挑战(2)),我们设计了一种多级队列算法.频繁设置 A/D 位和刷新热页的 TLB 是主要开销.根据局部性[23, 37],已经访问过的页面将来很可能会被访问​​多次.基于出于这种动机,多级队列放松了根据访问历史记录对热点页面的监控.在监控窗口中,vTMM通过多级队列过滤每个页面,决定是否清除页面的A/D位.多级队列以监控窗口为单位处理时间事件.开始时,所有页都处于级别 0.此时需要清除级别 0 的页的 A/D 位.对于级别 x (x &gt; 0),我们定义请勿打扰 (DND) 时间为 2x−1,这意味着级别 x 中页面的 A/D 位只有在 2 x−1 间隔后才会被清除(即监控窗口)稍后.直观上,该公式利用了内存访问局部性.活动页面越多,免打扰时间应该越长.请勿打扰时间内的页面被视为连续访问.当寻呼的 DND 时间结束时,应在该时间间隔内清除其 A/D 位.在下一个时间间隔,如果该页再次被设置 A/D 位,则表明该页处于活动状态(热).因此,我们升级了它的等级,使其免打扰时间更长.否则,说明该页面没有被持续访问,因此我们降低其级别以减少其免打扰时间.如果某页的电平下降到 0,我们就清除该页的 A/D 位.热点页免打扰时间较长,队列过滤掉其A/D位设置,并估算访问计数,而低级队列中的冷页免打扰时间较短,避免被误过滤掉而漏计数.</p></div>
    <div class="dir-tree"><ul><li><a href="../../md-docs/README" >README</a></li></ul><ul><li><a href="../../md-docs/contribute" >contribute</a></li></ul><ul><li><a href="../../virtual/虚拟化技术简介" >virtual</a><ul><li><a href="../../virtual/虚拟化技术简介" >虚拟化技术简介</a></li></ul><ul><li><a href="../../virtual/research" >research</a></li></ul><ul><li><a href="../../virtual/内存虚拟化" >内存虚拟化</a></li></ul><ul><li><a href="../../virtual/CPU虚拟化" >CPU虚拟化</a></li></ul><ul><li><a href="../../virtual/IO虚拟化" >IO虚拟化</a></li></ul><ul><li><a href="../../virtual/网络虚拟化" >网络虚拟化</a></li></ul><ul><li><a href="../../virtual/tools" >tools</a></li></ul><ul><li><a href="../../virtual/tier-mm" >tier-mm</a></li></ul></li></ul><ul><li><a href="../../qemu/intro" >qemu</a><ul><li><a href="../../qemu/intro" >intro</a></li></ul><ul><li><a href="../../qemu/glib" >glib</a></li></ul><ul><li><a href="../../qemu/qom" >qom</a></li></ul><ul><li><a href="../../qemu/system" >system</a></li></ul><ul><li><a href="../../qemu/tcg" >tcg</a></li></ul><ul><li><a href="../../qemu/vhost-user" >vhost-user</a></li></ul><ul><li><a href="../../qemu/EPT" >EPT</a></li></ul><ul><li><a href="../../qemu/machine" >machine</a></li></ul></li></ul><ul><li><a href="../../cxl/intro" >cxl</a><ul><li><a href="../../cxl/intro" >intro</a></li></ul></li></ul><ul><li><a href="../../kvm/intro" >kvm</a><ul><li><a href="../../kvm/intro" >intro</a></li></ul></li></ul></div>
    <div class="zood"><a class="" href="https://github.com/luzhixing12345/zood" target="_blank">zood</a></div>
    <script type="text/javascript" src="../../../js/next_front.js"></script><script>addLink("../../virtual/tools","../../qemu/intro","ab");</script><script type="text/javascript" src="../../../js/change_mode.js"></script><script>addChangeModeButton("../../../img/sun.png","../../../img/moon.png");</script><script type="text/javascript" src="../../../js/copy_code.js"></script><script>addCodeCopy("../../../img/before_copy.png","../../../img/after_copy.png");</script><script type="text/javascript" src="../../../js/navigator.js"></script><script type="text/javascript" src="../../../js/picture_preview.js"></script><script type="text/javascript" src="../../../js/global_js_configuration.js"></script>
</body>

</html>