
# 虚拟化技术简介

什么是虚拟化?狭义地说,大家在日常生活中说到的虚拟化主要指的还是 虚拟机 (Virtual Machine),即**通过虚拟化技术将一台计算机虚拟为多台逻辑计算机**, 这其实是虚拟化技术中的一个抽象粒度为单个计算机的分支:**系统虚拟化**.

在计算机科学当中,**虚拟化**(Virtualization)指的其实是一种「**将计算机的各种实体资源进行逻辑抽象,从而呈现出不同的虚拟资源**」的资源管理技术.利用虚拟化技术,我们可以打破实体结构间不可切割的特性. 一份实体资源可以对用户呈现为多份虚拟资源,多份实体资源也可以呈现为一份物理资源.

通过虚拟化技术,我们可以实现资源的动态分配、灵活调度、跨域共享等,从而提高资源的利用率.

![20240410204619](https://raw.githubusercontent.com/learner-lu/picbed/master/20240410204619.png)

> 这里所说的实体资源包括 **CPU、内存、磁盘空间、网络适配器**等

虚拟化技术的实现其实源自于现代计算机系统自下而上的多层抽象的结构:「**每个层次都向上一层次呈现一个抽象,每一层只需要知道下层的抽象接口,而无需了解其内部运作机制**」. 我们不难想到的是,**只要我们能够通过某种方式向上层提供表现相同的抽象接口,在上层看来我们就是正常的该层所提供的资源,从而就实现了对该层的虚拟化.**

由此,从物理层与虚拟层的两侧来看,我们便有了虚拟化中的两个重要定语

- 「**Host**」:物理资源方
- 「**Guest**」:虚拟资源方

根据资源的不同,在这两个定语之后我们可以接不同的名词:例如我们将一台物理机器称之为 `Host Machine` (宿主机),将运行在其上的虚拟机称之为 `Guest Machine` (客户机);相应地,在宿主机上若运行有操作系统,则称之为 `Host OS`,而运行在虚拟机中的操作系统称之为 `Guest OS`.

本质上,虚拟化就是由位于下层的软件模块,通过向上一层软件模块提供一个与它原先所期待的运行环境完全一致的接口的方法,抽象出一个虚拟的软件或硬件接口,使得上层软件可以直接运行在虚拟的环境上.虚拟化可以发生在现代计算机系统的各个层次上,不同层次的虚拟化会带来不同的虚拟化概念.因此,在学术界和工业界里,也先后出现了各种形形色色的虚拟化概念.我们将位于不同抽象层上的虚拟化分为如下类:

![20240411093621](https://raw.githubusercontent.com/learner-lu/picbed/master/20240411093621.png)

- **硬件抽象层**上的虚拟化

  硬件抽象层上的虚拟化是指通过虚拟硬件抽象层来实现虚拟机,为客户机操作系统呈现和物理硬件相同或相近的硬件抽象层.由于客户机操作系统所能看到的是硬件抽象层,因此客户机操作系统的行为和在物理平台上没有什么区别.
  
  通常来说,宿主机和客户机的ISA是相同的,客户机的大部分指令可以在宿主处理器上直接运行.只有那些需要虚拟化的指令才会由虚拟化软件进行处理,从而大大降低了虚拟化开销.另外,客户机和宿主机的硬件抽象层的其他部分如中断控制器、设备等,可以是完全不同的,当客户机对硬件抽象层访问时,虚拟化软件需要对此进行截获并模拟. **比较知名的硬件抽象层上的虚拟化有VMware的系列产品、Xen 等**.

- **操作系统层**上的虚拟化

  通常指的是操作系统内核可以提供多个互相隔离的用户态实例(通常称之为容器),这些用户态实例对其用户而言就像是一台真实的计算机,有着自己独立的网络、文件系统等(例如 VServer)

- **库函数层**上的虚拟化
  
  操作系统通常会通过应用级的库函数提供给应用程序一组服务,例如文件操作服务、时间操作服务等.这些库函数可以隐藏操作系统内部的一些细节,使得应用程序编程更为简单.不同的操作系统库函数有着不同的服务接口,例如Linux的服务接口是不同于Windows的.库函数层上的虚拟化就是通过虚拟化操作系统的应用级库函数的服务接口,使得应用程序不需要修改,就可以在不同的操作系统中无缝运行,从而提高系统间的互操作性.(例如 WINE系统是在Linux上模拟了Windows 的库函数接口、WSL 则相反)

- **编程语言层**上的虚拟化:
  这类虚拟机运行的是进程级别的不存在于硬件上的虚拟体系结构,其程序代码由虚拟机的运行时支持系统翻译成机器语言后再执行,属于进程级的虚拟化(例如 JVM)

> 例如 Linux kernel 当中的 VFS 便是非常符合虚拟化这一概念的子系统:从上层调用的角度而言,我们所看到的都是统一的 API 接口,不同文件系统的具体实现则被隐藏在了 VFS 层的下方.我们只需要知道在这一抽象层中 open、read、write 等抽象 API 的用法,而无需关注底层的 ext4 或是 ntfs 的内部实现.
>
> 虚拟化亦是如此,从 Guest 侧我们所能看到的也只是统一的虚拟资源的接口,或者说 Host 为我们呈现出了虚拟化的资源接口,其表现的行为与实体设备是一致的.

针对实体资源类型的不同,我们还可以再细分为:

- **计算虚拟化**:针对 CPU 和内存资源进行虚拟化.
- **网络虚拟化**:针对网络链路资源进行虚拟化.
- **IO 虚拟化**:针对 IO 资源进行虚拟化.
- **存储虚拟化**:针对磁盘存储资源虚拟化.

> 后文我们会分别来详细介绍这几部分虚拟化的特点

## 系统虚拟化

对于一台计算机,我们可以简单地抽象成下图所示的三层模型,从下往上分别是物理硬件层、操作系统层、应用程序层:

![20240411110652](https://raw.githubusercontent.com/learner-lu/picbed/master/20240411110652.png)

系统虚拟化是指**将一台物理计算机系统虚拟化为一台或多台虚拟计算机系统**.每个虚拟计算机系统(简称为虚拟机)都拥有自已的虚拟硬件(如CPU、内存和设备等),来提供一个独立的虚拟机执行环境. 通过虚拟化层的模拟,虚拟机中的操作系统认为自己仍然是独占一个系统在运行.每个虚拟机中的操作系统可以完全不同,并且它们的执行环境是完全独立的.

这个虚拟化层被称为虚拟机监控器(**VMM**, Virtual Machine Monitor), 这是一个介于 VM 与硬件中间的软件层,其负责 VM 的创建、销毁等工作,并为 VM 提供「虚拟硬件抽象层」的运行环境

![20240411112202](https://raw.githubusercontent.com/learner-lu/picbed/master/20240411112202.png)

1974年的一篇论文 [Formal Requirements for Virtualizable Third Generation Architectures](https://dl.acm.org/doi/pdf/10.1145/361011.361073) 中定义了虚拟机可以看作是物理机的一种高效隔离的复制, 并提出了满足虚拟化系统结构的 VMM 的三个典型特征

- **资源控制**(Resource Control),控制程序必须能够管理所有的系统资源.
- **等价性**(Equivalence),在控制程序管理下运行的程序(包括操作系统),除时序和资源可用性之外的行为应该与没有控制程序时的完全一致,且预先编写的特权指令可以自由地执行.
- **效率性**(Efficiency),绝大多数的客户机指令应该由主机硬件直接执行而无需控制程序的参与.

由此, 我们可以将 VMM 按虚拟平台和实现结构分为几类

## VMM 分类

在一台物理机上可以模拟出多台虚拟机(Virtual Machine,简称VM),每个虚拟机中都可以运行一个操作系统(OS).提供虚拟化的平台被称为VMM(Virtual Machine Monitor),在其上运行的虚拟机被称为guest VM(客户机).根据VMM支持的虚拟机制的不同,guest VM的运行模式可分为完全虚拟化(Full Virtualization)和类虚拟化(Para Virtualization).

### 完全虚拟化

如果一个基于硬件运行(native)的OS不需要修改任何代码就可以直接跑在VMM上,也就是guest OS根本感知不到自己运行在一个虚拟化环境中(可以说VMM是骗术高明的),这种就被称为"完全虚拟化". 从实现的角度来看,VMM需要能够并且正确处理客户机所有可能的行为,进一步说,客户机的行为是通过指令反映出来的,因此**VMM需要能够正确处理所有可能的指令**.对于完全虚拟化来说,所有可能的指令是指所虚拟的处理器手册规范上定义的所有指令.

最简单直接的方法就是,VMM对guest运行过程中的**每一条指令都进行解释和执行**,模拟出这条指令执行的效果,这种方法既适用于和VMM相同体系结构的guest,也能用于模拟和VMM不同体系结构的guest(比如物理CPU是x86的,而guest是基于ARM的),其缺点也很明显,就是**性能太差**.

但是有一些指令是要操作特权资源的,比如修改虚拟机的运行模式或者下面物理机的状态,读写时钟或者中断寄存器,这些指令被称为**敏感指令**,确实不适合由guest直接来控制; 其他的一些非敏感指令是完全可以在物理CPU上直接执行并返回结果给guest的,VMM只需要截获并模拟guest对敏感指令的执行和对特权资源的访问就可以了,以intel的VT-x和AMD的AMD-V为代表的硬件辅助虚拟化技术,就可以帮助VMM高效地识别和截获这些敏感指令.

像x86这种CISC架构的系统,指令繁杂,其中一些指令是难以虚拟化的,如果使用完全虚拟化,就需要通过**二进制代码翻译**(binary translation),扫描并修改guest的二进制代码,将难以虚拟化的指令转换成支持虚拟化的指令(ABI级),就像打补丁一样.

> 一个典型的例子是x86架构中的[CPUID](https://www.felixcloutier.com/x86/cpuid)指令.CPUID指令用于查询处理器的特性和能力,它会返回关于CPU的型号、特性、缓存大小等信息.在虚拟化环境中,**直接执行CPUID指令可能会暴露宿主机的敏感信息**,或者返回与虚拟机配置不一致的信息.
> 
> 为了解决这个问题,虚拟机监控器(VMM)或hypervisor通常会截获CPUID指令的执行,然后根据虚拟机的配置和策略来提供适当的响应.这个过程涉及到以下步骤:
> 
> - 截获指令:当虚拟机尝试执行CPUID指令时,VMM截获该指令,防止它直接在宿主机的处理器上执行.
> - 分析参数:VMM检查CPUID指令的输入参数,这些参数决定了CPUID将要返回的信息类型.
> - 构造响应:VMM根据虚拟机的配置和需要隐藏的信息来构造一个合适的响应.例如,VMM可能会修改返回的CPU特性集合,以反映虚拟机的硬件限制或安全策略.
> - 注入响应:VMM将构造好的响应注入到虚拟机的状态中,使得虚拟机认为CPUID指令已经执行,并得到了预期的结果.

### 类虚拟化

类虚拟化是通过**在源代码级别修改指令**以回避虚拟化漏洞的方式来使VMM能够对物理资源实现虚拟化.

上面谈到x86存在一些难以虚拟化的指令,完全虚拟化通过二进制翻译技术在二进制代码级别上来避免虚拟化漏洞.类虚拟化采取的是另一种思路,即**修改操作系统内核的代码**(即API级),**使得操作系统内核完全避免这些难以虚拟化的指令**.操作系统通常会使用到处理器提供的全部功能,例如特权级别、地址空间和控制寄存器等.

类虚拟化首先需要解决的问题就是如何插人VMM.典型的做法是修改操作系统的处理器相关代码,让操作系统主动让出特权级别,而运行在次一级特权上.这样,当操作系统试图去执行特权指令时,保护异常被触发,从而提供截获点供VMM来模拟.既然内核代码已经需要修改,类虚拟化进一步可以被用于优化I/O.也就是说,类虚拟化不是去模拟真实世界中的设备,因为太多的寄存器模拟会降低性能.相反,类虚拟化可以自定义出高度优化的I/O协议.这种I/O协议完全基于事务,可以达到近似物理机的速度

---

总的来说二者的区别如下:

**完全虚拟化(Full Virtualization)**

- 硬件兼容性:完全虚拟化技术通过模拟硬件的方式来实现虚拟化,使得客户操作系统能够在与原始硬件几乎相同的虚拟环境中运行.这意味着它**可以支持广泛的操作系统**,包括那些没有经过修改或优化以在虚拟化环境中运行的系统.
- 性能开销:完全虚拟化通常会**引入一定的性能开销**,因为它需要通过软件来模拟硬件操作,包括处理虚拟机的系统调用和硬件中断.
- 二进制翻译:在处理那些难以虚拟化的指令时,完全虚拟化可能**需要使用二进制翻译技术来转换客户操作系统的代码**,以确保它们能够在虚拟化环境中正确执行.
- 硬件辅助:完全虚拟化可以**利用硬件辅助虚拟化技术**(如Intel VT-x和AMD-V)来提高性能和效率,但即使没有这些硬件支持,它也能够运行.

**类虚拟化(Para virtualization)**

- 操作系统修改:类虚拟化**要求客户操作系统进行修改**,以便它知道自己是在虚拟化环境中运行.这些修改使得操作系统能够通过一组明确定义的API与虚拟机监控器(VMM)进行交互.
- 性能优势:由于类虚拟化避免了模拟硬件的需要,并且客户操作系统能够直接与VMM通信,因此它可以提供比完全虚拟化**更低的性能开销**.
- 灵活性和可扩展性:类虚拟化提供了更高的灵活性和可扩展性,因为它允许VMM和客户操作系统紧密合作,共享资源和信息.
- 适用范围限制:类虚拟化的一个限制是它通常不支持未经修改的操作系统,这意味着**只有经过特殊修改的操作系统才能在类虚拟化环境中运行**.


该论文尽管基于简化的假设,但上述条件仍为评判一个计算机体系结构是否能够有效支持虚拟化提供了一个便利方法,也为设计可虚拟化的计算机架构给出了指导原则.同时论文中介绍了两种 Hypervisor 类型.

- Type 1: **Hypervisor模型**, VMM 直接运行在硬件上,即以 VMM 作为 Host OS 直接管控硬件资源.

  ![20240411180335](https://raw.githubusercontent.com/learner-lu/picbed/master/20240411180335.png)

  Type1 类模型不是安装在操作系统 (OS) 上的软件应用程序;相反,它包含并集成了重要的操作系统组件,例如内核. 这种场景下**VMM是一个完备的操作系统**,它除了具备传统操作系统的功能,还具备虚拟化功能.包括CPU、内存和I/O设备在内的所有物理资源都归VMM所有,因此**VMM不仅要负责虚拟机环境的创建和管理,还承担着管理物理资源的责任**

  尽管这种方式是比较高效的,然而I/O设备种类繁多,管理所有设备就意味着大量的驱动开发工作, 这对于操作系统内核维护者来说无疑是一项巨大的挑战. 

  > 例如 [VMware ESXI](https://en.wikipedia.org/wiki/VMware_ESXi) [Microsoft Hyper-V](https://en.wikipedia.org/wiki/Hyper-V)

- Type 2: **Host模型**, VMM 运行在传统的操作系统上,与其他应用程序并行运行.

  ![20240411181634](https://raw.githubusercontent.com/learner-lu/picbed/master/20240411181634.png)

  在host模型中,物理资源由host OS管理,host OS是传统操作系统(比如Linux),这些传统操作系统并不是为虚拟化而设计的,因此**Host OS本身并不具备虚拟化功能,实际的虚拟化功能由VMM来提供.** VMM作为host OS中一个独立的内核模块,通过调用host OS的服务来获得资源,实现CPU、内存和I/O设备的虚拟化.VMM创建出虚拟机之后,**通常将虚拟机作为host OS的一个进程参与调度.**

  Host模型最大的优点就是可以充分利用现有操作系统的设备驱动程序,VMM不需要为各种I/O设备重新实现驱动,可以专注于物理资源的虚拟化;缺点在于,由于VMM是借助host OS的服务来操作硬件,而不是直接操作硬件,因此受限于host OS服务的支持,可能导致硬件利用的不充分.

  > 例如 [VMware workstation](https://en.wikipedia.org/wiki/VMware_Workstation) [VirtualBox](https://en.wikipedia.org/wiki/VirtualBox)

  从架构上看,由Qumranet公司开发的KVM(Kernel-based Virtual Machine)就是属于host模型的,kernel-based,顾名思义就是基于操作系统内核.KVM于2007年被[集成](http://kernelnewbies.org/Linux_2_6_20#head-bca4fe7ffe454321118a470387c2be543ee51754)到Linux内核2.6.20版本,并于2008年被Red Hat收购.

  随着越来越多的虚拟化功能被加入到Linux内核当中,Linux已经越来越像一个hypervisor了,从这个角度看,KVM也可以算是hypervisor模型了.


现代虚拟机主要使用的是Type 1和Type 2的类型,同时也有混合类型的应用.

Type 1虚拟机,也称为裸机虚拟机,直接在物理硬件上运行,不需要底层的宿主操作系统.这种类型的虚拟机通常提供更高的性能和直接访问硬件资源的能力.Type 1虚拟机的例子包括VMware ESXi和Microsoft Hyper-V.

Type 2虚拟机,也称为宿主虚拟机,运行在宿主操作系统之上.这种类型的虚拟机易于安装和使用,但可能在性能上不如Type 1虚拟机.Type 2虚拟机的例子包括VMware Workstation和Oracle VirtualBox.

混合类型的虚拟机结合了Type 1和Type 2的特点,可以在裸机上运行,也可以在宿主操作系统上运行.例如,VMware vSphere提供了一个统一的虚拟化平台,允许在物理硬件和宿主操作系统上运行虚拟机48.

在现代虚拟化环境中,**Type 1虚拟机因其性能优势通常用于企业级和数据中心环境,而Type 2虚拟机则因其易用性和灵活性适用于个人开发者和小型项目**.混合类型的虚拟机提供了更多的部署选项和灵活性,以满足不同场景的需求.

---

VMM(Virtual Machine Monitor)和Hypervisor是虚拟化技术中的两个术语,它们在某些文献和上下文中可以互换使用,但在技术上它们有着细微的区别.

首先,VMM通常指的是虚拟机监控器,它是一个软件层,负责创建、运行和管理虚拟机(VMs).VMM的主要任务是调节对底层硬件的访问,以保证各个运行在虚拟机中的客户操作系统能共享同一台真实机器的物理资源.VMM的分类根据其在整个物理系统中的实现位置及实现方法不同,主要有两种形式:Hypervisor VM和Hosted VM2.

Hypervisor,也称为Type 1 Hypervisor,是一种特殊类型的VMM,它直接运行在物理硬件上,不需要底层操作系统.Hypervisor可以看作是一个轻量级的操作系统,它拥有并管理所有物理资源,并且提供一个或多个虚拟机运行客户操作系统.由于Hypervisor直接与硬件交互,它能够提供较高的性能和安全性915.

总的来说,Hypervisor是VMM的一种特定类型,即Type 1 Hypervisor,而VMM是一个更广泛的术语,包括了Hypervisor和其他虚拟化技术.在某些情况下,这两个术语可能会被交替使用,但理解它们之间的区别有助于更好地理解虚拟化的不同实现和应用场景.

![20240411093018](https://raw.githubusercontent.com/learner-lu/picbed/master/20240411093018.png)

## 云服务虚拟化

云计算如今已是一个相当热门的概念,各行各业包括政府,云建设都如火如荼地进行.云简而言之就是把IT资源服务化.过去办公场景中我们每人一台PC,拥有独立的IT资源,而云可以将IT资源按需分配给需要的租户,实现按需、弹性拓展.以前每个人一台PC.现在大家共享一台超级PC,按需访问,不用时资源自动释放,可供其他用户使用,这样资源得以最大化利用,并且可以按需扩展,及时满足使用需求.

个人PC机的操作系统向下管理和驱动底层硬件,如CPU、内存、硬盘等,管理计算任务,调配资源, 向上为各类应用软件提供统一、标准的接口.

云操作系统功能有些类似,但功能更复杂.**云操作系统它负责管理和调配一个或多个数据中心的硬件资源,这些资源可能由数量巨大的服务器、存储设备组成,并逻辑上把它们整合一台虚拟计算机系统,供上层云应用使用**.为了提升硬件资源使用效率,一台硬件设备会首先被虚拟成多个具备独立功能的虚拟设备,以便同时供多个应用调用,这就涉及到虚拟化技术,这也是云操作系统的关键技术之一.而当前具备这种虚拟化功能的技术维基百科列举的就有超过60种,其中有四种虚拟化技术是当前最为成熟而且运用最广泛的,分别是:VMware的ESX、微软Hyper-V、开源的Xen和KVM等,下面将针对这4种虚拟化技术架构进行分析

### KVM虚拟化架构

> [!TIP]
> KVM虚拟化技术架构是应用场景最广泛的虚拟化技术之一, 大多数云服务器厂商都是基于KVM虚拟化技术架构
>
> 而且 QEMU 和 KVM 的相关代码都是开源的, 非常方便理解和阅读

KVM的全称是Kernel-based Virtual Machine,字面意思是基于内核虚拟机.其最初是由Qumranet公司开发的一个开源项目,2008年,Qumranet被RedHat所收购,但KVM本身仍是一个开源项目,由RedHat、IBM等厂商支持.

与XEN类似,KVM支持广泛的CPU架构,除了X86/X86_64 CPU架构之外,还将会支持大型机(S/390)、小型机(PowerPC、IA64)及ARM等.

KVM充分利用了CPU的硬件辅助虚拟化能力,并重用了Linux内核的诸多功能,使得KVM本身是非常瘦小的,KVM的创始者Avi Kivity声称KVM模块仅有约10000行代码,但我们不能认为KVM的Hypervisor就是这个代码量,因为从严格意义来说,KVM本身并不是 Hypervisor,它仅是Linux内核中的一个可装载模块,其功能是将Linux内核转换成一个裸金属的Hypervisor.

**通过KVM模块的加载将Linux内核转变成Hypervisor,KVM在Linux内核的用户(User)模式和内核(Kernel)模式基础上增加了客户(Guest)模式.Linux本身运行于内核模式,主机进程运行于用户模式,虚拟机则运行于客户模式,使得转变后的Linux内核可以将主机进程和虚拟机进行统一的管理和调度,这也是KVM名称的由来**.

KVM 用来模拟 CPU 的运行,但缺少了对 Network 和 I/O 的支持.QEMU-KVM 是一个完整的模拟器,它基于 KVM 上,提供了完整的 Network 和 I/O 支持.其中 Openstack 为了跨 VM 性,所以不会直接控制 QEMU-KVM,而是通过 libvit 的库去间接控制 QEMU-KVM .

KVM利用修改的QEMU提供BIOS、显卡、网络、磁盘控制器等的仿真,但对于I/O设备(主要指网卡和磁盘控制器)来说,则必然带来性能低下的问题.因此,KVM也引入了半虚拟化的设备驱动,通过虚拟机操作系统中的虚拟驱动与主机Linux内核中的物理驱动相配合,提供近似原生设备的性能.从此可 以看出,KVM支持的物理设备也即是Linux所支持的物理设备.

### ESX虚拟化架构

ESX是VMware的企业级虚拟化产品,ESX服务器启动时,首先启动Linux Kernel,通过这个操作系统加载虚拟化组件,最重要的是ESX的Hypervisor组件,称之为VMkernel,VMkernel会从 LinuxKernel完全接管对硬件的控制权,而该Linux Kernel作为VMkernel的首个虚拟机,用于承载ESX的serviceConsole,实现本地的一些管理功能.

VMkernel负责为所承载的虚拟机调度所有的硬件资源,但不同类型的硬件会有些区别.

虚拟机对于CPU和内存资源是通过VMkernel直接访问,最大程度地减少了开销,CPU的直接访问得益于CPU硬件辅助虚拟化(Intel VT-x和AMD AMD-V,第一代虚拟化技术),内存的直接访问得益于MMU(内存管理单元)硬件辅助虚拟化.

虚拟机对于I/O设备的访问则有多种方式,以网卡为例,有两种方式可供选择:一是利用I/O MMU硬件辅助虚拟化的VMDirectPath I/O,使得虚拟机可以直接访问硬件设备,从而减少对CPU的开销;二是利用半虚拟化的设备VMXNETx,网卡的物理驱动在VMkernel中,在虚拟机中装载网卡的虚拟驱动,通过这二者的配对来访问网卡,与仿真式网卡相比有着较高的效率.半虚拟化设备的安装是由虚拟机中 VMware tool来实现的,可以在Windows虚拟机的右下角找到它.网卡的这两种方式,前者有着显著的先进性,但后者用得更为普遍,因为 VMDirectPath I/O与VMware虚拟化的一些核心功能不兼容,如:热迁移、快照、容错、内存过量使用等.

ESX的物理驱动是内置在Hypervisor中,所有设备驱动均是由VMware预植入的.因此,ESX对硬件有严格的兼容性列表,不在列表中的硬件,ESX将拒绝在其上面安装.

### Hyper-V虚拟化架构

Hyper-V是微软新一代的服务器虚拟化技术,首个版本于2008年7月发布,Hyper-V有两种发布版本:一是独立版,如Hyper-V Server 2008,以命令行界面实现操作控制,是一个免费的版本;二是内嵌版,如Windows Server 2008,Hyper-V作为一个可选开启的角色.

对于一台没有开启Hyper-V角色的Windows Server 2008来说,这个操作系统将直接操作硬件设备,一旦在其中开启了Hyper-V角色,系统会要求重新启动服务器.在这次重启动过程中,**Hyper-V的Hypervisor接管了硬件设备的控制权**,先前的Windows Server 2008则成为Hyper-V的首个虚拟机,称之为父分区,负责其他虚拟机(称为子分区)以及I/O设备的管理.Hyper-V要求CPU必须具备硬件辅助虚拟化,但对MMU硬件辅助虚拟化则是一个增强选项.

其实**Hypervisor仅实现了CPU的调度和内存的分配,而父分区控制着I/O设备,它通过物理驱动直接访问网卡、存储等**.子分区要访问I/O设备需要通过子分区操作系统内的VSC(虚拟化服务客户端),对VSC的请求由VMBUS(虚拟机总线)传递到父分区操作系统内的VSP(虚拟化服务提供者),再由VSP重定向到父分区内的物理驱动,每种I/O设备均有各自的VSC和VSP配对,如存储、网络、视频和输入设备等,整个I/O设备访问过程对于子分区的操作系统是透明的.其实在子分区操作系统内,VSC和VMBUS就是作为I/O设备的虚拟驱动,它是子分区操作系统首次启动时由Hyper-V 提供的集成服务包安装,这也算是一种半虚拟化的设备,使得虚拟机与物理I/O设备无关.如果子分区的操作系统没有安装Hyper-V集成服务包或者不支持 Hyper-V集成服务包(对于这种操作系统,微软称之为Unenlightened OS,如未经认证支持的Linux版本和旧的Windows版本),则这个子分区只能运行在仿真状态.其实微软所宣称的启蒙式 (Enlightenment)操作系统,就是支持半虚拟化驱动的操作系统.

Hyper-V的Hypervisor是一个非常精简的软件层,不包含任何物理驱动,物理服务器的设备驱动均是驻留在父分区的Windows Server 2008中,驱动程序的安装和加载方式与传统Windows系统没有任何区别.因此,只要是Windows支持的硬件,也都能被Hyper-V所兼容.

### Xen虚拟化架构

XEN最初是剑桥大学Xensource的一个开源研究项目,2003年9月发布了首个版本XEN 1.0,2007年Xensource被Citrix公司收购,开源XEN转由www.xen.org继续推进,该组织成员包括个人和公司(如 Citrix、Oracle等).该组织在2011年3月发布了版本XEN 4.1.

相对于ESX和Hyper-V来说,XEN支持更广泛的CPU架构,前两者只支持CISC的X86/X86_64 CPU架构,XEN除此之外还支持RISC CPU架构,如IA64、ARM等.

XEN的Hypervisor是服务器经过BIOS启动之后载入的首个程序,然后启动一个具有特定权限的虚拟机,称之为Domain 0(简称Dom 0).Dom 0的操作系统可以是Linux或Unix,Domain 0实现对Hypervisor控制和管理功能.在所承载的虚拟机中,Dom 0是唯一可以直接访问物理硬件(如存储和网卡)的虚拟机,它通过本身加载的物理驱动,为其它虚拟机(Domain U,简称DomU)提供访问存储和网卡的桥梁.

XEN支持两种类型的虚拟机,一类是半虚拟化(PV,Paravirtualization),另一类是全虚拟化(XEN称其为 HVM,Hardware Virtual Machine).半虚拟化需要特定内核的操作系统,如基于Linux paravirt_ops(Linux内核的一套编译选项)框架的Linux内核,而Windows操作系统由于其封闭性则不能被XEN的半虚拟化所支持,XEN的半虚拟化有个特别之处就是不要求CPU具备硬件辅助虚拟化,这非常适用于2007年之前的旧服务器虚拟化改造.全虚拟化支持原生的操作系统, 特别是针对Windows这类操作系统,XEN的全虚拟化要求CPU具备硬件辅助虚拟化,它修改的Qemu仿真所有硬件,包括:BIOS、IDE控制器、 VGA显示卡、USB控制器和网卡等.为了提升I/O性能,全虚拟化特别针对磁盘和网卡采用半虚拟化设备来代替仿真设备,这些设备驱动称之为PV on HVM,为了使PV on HVM有最佳性能.CPU应具备MMU硬件辅助虚拟化.

XEN的Hypervisor层非常薄,少于15万行的代码量,不包含任何物理设备驱动,这一点与Hyper-V是非常类似的,物理设备的驱动均是驻留在Dom 0中,可以重用现有的Linux设备驱动程序.因此,XEN对硬件兼容性也是非常广泛的,Linux支持的,它就支持.

## 参考

- 系统虚拟化 原理与实现 第一章 第三章
- [虚拟化技术系列](https://zhuanlan.zhihu.com/p/93289632)
- [<深入浅出系统虚拟化:原理与实践> 专栏](https://www.zhihu.com/column/c_1438541945043488769)
- [10 个最佳 Linux 虚拟化软件](https://linux.cn/article-15911-1.html)
- [了解虚拟化](https://www.redhat.com/zh/topics/virtualization)
- [操作系统层虚拟化](https://zh.wikipedia.org/wiki/%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1%E5%B1%A4%E8%99%9B%E6%93%AC%E5%8C%96)
- [虚拟化技术简介](https://ctf-wiki.org/pwn/virtualization/basic-knowledge/basic-knowledge/)
- [【VIRT.0x02】系统虚拟化导论](https://arttnba3.cn/2022/08/29/VURTUALIZATION-0X02-BASIC_KNOWLEDGE/)
- [重学 Docker - part1: 虚拟化技术简述](https://zhuanlan.zhihu.com/p/363922044)
- [虚拟化技术概览](https://houmin.cc/posts/65866329/)
- [虚拟机技术](https://zhuanlan.zhihu.com/p/608726848)