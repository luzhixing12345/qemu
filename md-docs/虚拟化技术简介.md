
# 虚拟化技术简介

什么是虚拟化?狭义地说,大家在日常生活中说到的虚拟化主要指的还是 虚拟机 (Virtual Machine),即**通过虚拟化技术将一台计算机虚拟为多台逻辑计算机**, 这其实是虚拟化技术中的一个抽象粒度为单个计算机的分支:**系统虚拟化**.

在计算机科学当中,**虚拟化**(Virtualization)指的其实是一种「**将计算机的各种实体资源进行逻辑抽象,从而呈现出不同的虚拟资源**」的资源管理技术.利用虚拟化技术,我们可以打破实体结构间不可切割的特性. 一份实体资源可以对用户呈现为多份虚拟资源,多份实体资源也可以呈现为一份物理资源.

通过虚拟化技术,我们可以实现资源的动态分配、灵活调度、跨域共享等,从而提高资源的利用率.

![20240410204619](https://raw.githubusercontent.com/learner-lu/picbed/master/20240410204619.png)

> 这里所说的实体资源包括 **CPU、内存、磁盘空间、网络适配器**等

虚拟化技术的实现其实源自于现代计算机系统自下而上的多层抽象的结构:「**每个层次都向上一层次呈现一个抽象,每一层只需要知道下层的抽象接口,而无需了解其内部运作机制**」. 我们不难想到的是,**只要我们能够通过某种方式向上层提供表现相同的抽象接口,在上层看来我们就是正常的该层所提供的资源,从而就实现了对该层的虚拟化.**

由此,从物理层与虚拟层的两侧来看,我们便有了虚拟化中的两个重要定语

- 「**Host**」:物理资源方
- 「**Guest**」:虚拟资源方

根据资源的不同,在这两个定语之后我们可以接不同的名词:例如我们将一台物理机器称之为 `Host Machine` (宿主机),将运行在其上的虚拟机称之为 `Guest Machine` (客户机);相应地,在宿主机上若运行有操作系统,则称之为 `Host OS`,而运行在虚拟机中的操作系统称之为 `Guest OS`.

## 系统虚拟化简史

## VMM 分类

在一台物理机上可以模拟出多台虚拟机(Virtual Machine,简称VM),每个虚拟机中都可以运行一个操作系统(OS).提供虚拟化的平台被称为VMM(Virtual Machine Monitor),在其上运行的虚拟机被称为guest VM(客户机).根据VMM支持的虚拟机制的不同,guest VM的运行模式可分为完全虚拟化(Full Virtualization)和类虚拟化(Para Virtualization).

### 完全虚拟化

如果一个基于硬件运行(native)的OS不需要修改任何代码就可以直接跑在VMM上,也就是guest OS根本感知不到自己运行在一个虚拟化环境中(可以说VMM是骗术高明的),这种就被称为"完全虚拟化".在这种模式下,VMM需要正确处理guest所有可能的指令.

最简单直接的方法就是,VMM对guest运行过程中的**每一条指令都进行解释和执行**,模拟出这条指令执行的效果,这种方法既适用于和VMM相同体系结构的guest,也能用于模拟和VMM不同体系结构的guest(比如物理CPU是x86的,而guest是基于ARM的),其缺点也很明显,就是**性能太差**.

但是有一些指令是要操作特权资源的,比如修改虚拟机的运行模式或者下面物理机的状态,读写时钟或者中断寄存器,这些指令被称为**敏感指令**,确实不适合由guest直接来控制; 其他的一些非敏感指令是完全可以在物理CPU上直接执行并返回结果给guest的,VMM只需要截获并模拟guest对敏感指令的执行和对特权资源的访问就可以了,以intel的VT-x和AMD的AMD-V为代表的硬件辅助虚拟化技术,就可以帮助VMM高效地识别和截获这些敏感指令.

像x86这种CISC架构的系统,指令繁杂,其中一些指令是难以虚拟化的,如果使用完全虚拟化,就需要通过**二进制代码翻译**(binary translation),扫描并修改guest的二进制代码,将难以虚拟化的指令转换成支持虚拟化的指令(ABI级),就像打补丁一样.

> 一个典型的例子是x86架构中的[CPUID](https://www.felixcloutier.com/x86/cpuid)指令.CPUID指令用于查询处理器的特性和能力,它会返回关于CPU的型号、特性、缓存大小等信息.在虚拟化环境中,**直接执行CPUID指令可能会暴露宿主机的敏感信息**,或者返回与虚拟机配置不一致的信息.
> 
> 为了解决这个问题,虚拟机监控器(VMM)或hypervisor通常会截获CPUID指令的执行,然后根据虚拟机的配置和策略来提供适当的响应.这个过程涉及到以下步骤:
> 
> - 截获指令:当虚拟机尝试执行CPUID指令时,VMM截获该指令,防止它直接在宿主机的处理器上执行.
> - 分析参数:VMM检查CPUID指令的输入参数,这些参数决定了CPUID将要返回的信息类型.
> - 构造响应:VMM根据虚拟机的配置和需要隐藏的信息来构造一个合适的响应.例如,VMM可能会修改返回的CPU特性集合,以反映虚拟机的硬件限制或安全策略.
> - 注入响应:VMM将构造好的响应注入到虚拟机的状态中,使得虚拟机认为CPUID指令已经执行,并得到了预期的结果.

### 类虚拟化

类虚拟化是通过**在源代码级别修改指令**以回避虚拟化漏洞的方式来使VMM能够对物理资源实现虚拟化.

上面谈到x86存在一些难以虚拟化的指令,完全虚拟化通过二进制翻译技术在二进制代码级别上来避免虚拟化漏洞.类虚拟化采取的是另一种思路,即**修改操作系统内核的代码**(即API级),**使得操作系统内核完全避免这些难以虚拟化的指令**.操作系统通常会使用到处理器提供的全部功能,例如特权级别、地址空间和控制寄存器等.

类虚拟化首先需要解决的问题就是如何插人VMM.典型的做法是修改操作系统的处理器相关代码,让操作系统主动让出特权级别,而运行在次一级特权上.这样,当操作系统试图去执行特权指令时,保护异常被触发,从而提供截获点供VMM来模拟.既然内核代码已经需要修改,类虚拟化进一步可以被用于优化I/O.也就是说,类虚拟化不是去模拟真实世界中的设备,因为太多的寄存器模拟会降低性能.相反,类虚拟化可以自定义出高度优化的I/O协议.这种I/O协议完全基于事务,可以达到近似物理机的速度

---

总的来说二者的区别如下:

**完全虚拟化(Full Virtualization)**

- 硬件兼容性:完全虚拟化技术通过模拟硬件的方式来实现虚拟化,使得客户操作系统能够在与原始硬件几乎相同的虚拟环境中运行.这意味着它**可以支持广泛的操作系统**,包括那些没有经过修改或优化以在虚拟化环境中运行的系统.
- 性能开销:完全虚拟化通常会**引入一定的性能开销**,因为它需要通过软件来模拟硬件操作,包括处理虚拟机的系统调用和硬件中断.
- 二进制翻译:在处理那些难以虚拟化的指令时,完全虚拟化可能**需要使用二进制翻译技术来转换客户操作系统的代码**,以确保它们能够在虚拟化环境中正确执行.
- 硬件辅助:完全虚拟化可以**利用硬件辅助虚拟化技术**(如Intel VT-x和AMD-V)来提高性能和效率,但即使没有这些硬件支持,它也能够运行.

**类虚拟化(Para virtualization)**

- 操作系统修改:类虚拟化**要求客户操作系统进行修改**,以便它知道自己是在虚拟化环境中运行.这些修改使得操作系统能够通过一组明确定义的API与虚拟机监控器(VMM)进行交互.
- 性能优势:由于类虚拟化避免了模拟硬件的需要,并且客户操作系统能够直接与VMM通信,因此它可以提供比完全虚拟化**更低的性能开销**.
- 灵活性和可扩展性:类虚拟化提供了更高的灵活性和可扩展性,因为它允许VMM和客户操作系统紧密合作,共享资源和信息.
- 适用范围限制:类虚拟化的一个限制是它通常不支持未经修改的操作系统,这意味着**只有经过特殊修改的操作系统才能在类虚拟化环境中运行**.


## 参考

- [虚拟化技术系列](https://zhuanlan.zhihu.com/p/93289632)
- [深入理解虚拟化](https://zhuanlan.zhihu.com/p/441287815)
- 系统虚拟化 原理与实现
- 深度探索Linux系统虚拟化:原理与实现 (王柏生  谢广军) 
- NewBluePill深入理解硬件虚拟机 (于淼  戚正伟)
- [<深入浅出系统虚拟化:原理与实践> 专栏](https://www.zhihu.com/column/c_1438541945043488769)
- [10 个最佳 Linux 虚拟化软件](https://linux.cn/article-15911-1.html)
- [了解虚拟化](https://www.redhat.com/zh/topics/virtualization)
- [操作系统层虚拟化](https://zh.wikipedia.org/wiki/%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1%E5%B1%A4%E8%99%9B%E6%93%AC%E5%8C%96)
- [虚拟化技术简介](https://ctf-wiki.org/pwn/virtualization/basic-knowledge/basic-knowledge/)